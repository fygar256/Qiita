


**************************************************


全ての情報を含むπから任意の情報を取り出す試みinfo.py


**************************************************


info.py
円周率πは無限大の情報量を持ち、全ての情報を含んでいます。

このプログラムは円周率を発生させ、文字にデコードし、円周率に含まれる情報を取り出します。

意中の人の電話番号も、もちろん円周率の中に含まれているので、πを持っているだけで、「意中の人の電話番号の情報を持っている」と言えます。但し、πの中のどこからどこまでかは分からないため、「意中の人の電話番号を知っている」とは言えません。

πを持っているだけで、と書きましたが、持っているπの桁数が有限ならば、その中に意中の人の電話番号がない可能性があるので、その場合、意中の人の電話番号を持っているとは言えません。

このプログラムのデコード方法は、i=" 0123456789.,abcdefghijklmnopqrstuvwxyz"という文字列を使い、十進数で２桁ずつ区切って100で割り、iの長さを掛けて、iに当てはめるというものです。
取り出せる情報はデコード方法によって変わります。πは上質の乱数列なので、殆どが無駄な情報で、実用的とは言えませんが、無限に続ければ多分期待した文字列は出てくるので、辛抱強く待ち続けましょう。但し、多分その前に地球が滅亡してしまうでしょう。

このプログラムのような単純なデコード方法で、円周率の中から任意の情報を引き出すことができるかどうかは、可能、不可能、2つの説があります。このプログラムのπの発生はガウス・ルジャンドル法に依ります。

何もかも知ってをるなり竈猫　富安風生

意中の人の電話番号は、竈猫に聞いたら分かりますが、猫はナンバーを喋れないので、猫語のデコードが必要です。πは竈猫です。
これがまあ、情報の内在性と言っていいでしょう。

```info.py
#!/usr/bin/python3
import sys
k, a, b, a1, b1 = 2, 4, 1, 12, 4
i=" 0123456789.,abcdefghijklmnopqrstuvwxyz"
f=0
while(True):
  # Next approximation
  p, q, k = k*k, 2*k+1, k+1
  a, b, a1, b1 = a1, b1, p*a+q*a1, p*b+q*b1
  # Print common digits
  d = a / b
  d1 = a1 / b1
  n1=-1
  while(d == d1):
    if n1==-1:
        pass
    else:
        n=int((int(n1)*10+int(d))/100*len(i))
        print(i[n],end='')
    n1=d
    sys.stdout.flush()
    a, a1 = 10*(a%b), 10*(a1%b1)
    d, d1 = a/b, a1/b1
```
このプログラムのガウス・ルジャンドル法では、時間さえあればπの値が取り出せるので、有限のメモリから無限の情報を引き出すことが出来ます。でも、人類に与えられた時間は有限です。無限と仮定したら面白いでしょう。

完全乱数は存在します。僕は数学的存在証明を知りませんが、イデア界には存在します、
完全乱数からは下のデコード方法で任意の情報を取り出せるので、下のプログラムを持っているだけで、
「意中の人の電話番号を取り出すことのできるプログラムを持っている」と言えます。
但し、現存のコンピュータは今の所有限なので、チューリングマシンが必要です。
/dev/randomの環境ノイズから取り出せる乱数は、本当は真性乱数と言います。
ここでは、真性乱数を完全乱数であると仮定しています。

```phoneno.py
#!/usr/bin/python3
import os
import binascii


def main():
    f=open("/dev/random",'rb') # /dev/randomを開く
    while(1):
        randomdata=f.read(1) # 1バイトの完全乱数の読み出し
        randomhex=binascii.hexlify(randomdata) #１６進の文字列に変換
        randomint=int(randomhex,16) # 整数に変換
        i='0123456789 '
        n=randomint/256*len(i)
        print(i[n],end='')
    f.close() # /dev/randomを閉じる
    return

if __name__=='__main__':
	main()
	exit(0)

```
# 同じアイディアのプログラムで、3桁の金庫の鍵のナンバーを当てるプログラムを作ってみました。

実際、眠剤を飲む必要に迫られて、3桁の薬箱の鍵のナンバーを当てる試行をしてみましたが、数回では当たりませんでした。
確率pで起こる事象の持つ情報量は-log_2 p　なので、
1/1000の確率で当たる金庫の鍵クイズの答が持つ情報量は-log_2 1/1000=3log_2 10=6.907755279です。

初歩的な情報理論については、ここが

https://www.momoyama-usagi.com/entry/info-entropy

簡単に書いてるし、参考にゃなります。
確率0で起こる事象が起こったら情報量無限大で、
確率1で起こる事象が起こったら情報量０ですにゃ。

情報量という言葉の定義は2つ必要で、
①情報理論で定量的に定義した「情報量」。
②ただ単に１ビットの情報が何桁並んでいるかを表した「情報量」。
でんにゃ。単位は[bit]です。

```3.py
#!/usr/bin/python3
import os
import binascii

def main():
    f=open("/dev/random",'rb') # /dev/randomを開く
    s=""
    cnt=0
    while(1):
        randomdata=f.read(1) # 1バイトの真性乱数を読み出し

        randomhex=binascii.hexlify(randomdata) #１６進の文字列に変換
        randomint=int(randomhex,16) # 整数に変換
        i='0123456789'
        n=int(randomint/256*len(i))
        s=s+i[n]
        if len(s)>3:
            s=s[1:]
        cnt=cnt+1
        if len(s)>=3:
            print(cnt,s)
    f.close() # /dev/randomを閉じる
    return

if __name__=='__main__':
	main()
	exit(0)
```
